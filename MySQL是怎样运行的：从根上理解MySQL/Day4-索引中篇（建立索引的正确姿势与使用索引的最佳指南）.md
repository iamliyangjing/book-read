## Day4-索引中篇（建立索引的正确姿势与使用索引的最佳指南）



首先先思考这几个问题：

1.   索引虽然能给`MySQL`检索数据的效率带来质的飞跃，但加入索引没有带来新问题吗？
2. 既然索引能够提升查询性能，那是不是为表中每个字段建立索引，性能会更好？
3. 一张数据表中，哪些类型的字段不适合建立索引呢？又是因为什么原因呢？
4. 表中会存在大量的字段，但其中哪些字段建立索引才能够最大的性能收益呢？
5. `MySQL`提供的索引种类也不少，一个字段上建立什么类型的索引才最好呢？
6. 当表中存在多个索引时，一条查询`SQL`有多条路径可走，此时走哪条索引最好？



### 建立索引好处和坏处

好处：

- 整个数据库中，数据表的查询速度直线提升，数据量越大时效果越明显。
- 通过创建唯一索引，可以确保数据表中的数据唯一性，无需额外建立唯一约束。
- 在使用**分组和排序**时，同样可以显著减少`SQL`查询的分组和排序的时间。
- 连表查询时，基于主外键字段上建立索引，可以带来十分明显的性能提升。
- 索引默认是`B+Tree`有序结构，基于索引字段做范围查询时，效率会明显提高。
- 从`MySQL`整体架构而言，减少了查询`SQL`的执行时间，提高了数据库整体吞吐量。



坏处：

- 建立索引会生成本地磁盘文件，需要额外的空间存储索引数据，磁盘占用率会变高。
- 写入数据时，**需要额外维护索引结构，增、删、改数据时，都需要额外操作索引**
- 写入数据时维护索引需要**额外的时间开销**，执行写`SQL`时效率会降低，性能会下降。

​	

### 各个索引的优劣分析

- 主键索引必须是自增，避免产生页分裂

- 联合索引必须遵循**最左前缀原则**

- 前缀索引在order by、group by、索引覆盖情况下无法使用

- 全文索引基于分词实现的，**对一个字段建立全文索引后，MySQL会对该字段做分词处理**，因此全文索引文件会额外的大！
- **唯一索引存在快慢问题**，查询比普通索引快，普通索引还要判断是否有相同的值，更新比普通索引慢，因为要确保数据不重复
- 哈希索引无法做范围内查询，无法做排序、分组等工作。



### 建立索引的正确姿势

- 注意回表问题
- 建立索引遵循原则
  - 区分度高
  - where 、group by、 order by
  - 经常修改的字段。
  - 经常做查询的字段。
  - 做索引的字段不宜过长。
  - 一张表的索引**一般控制在3个，不超过5个**。
- 最左前缀原则(<font color='red'>**注意只要是查询的字段包含在联合索引，都可以使用索引查询**</font>)



### 索引失效

首先可以使用explain语句来分析索引是否使用

id、select_type、table、possible_key、key、key_len、ref、rows、Extra

- 使用or语句查询
- like%
- 类型转换
- 运算
- 函数
- null
- 最左前缀失效
- 快表(扫描索引行数超过30%)

### 使用索引的正确姿势

- 索引覆盖->联合索引-> 减少回表
- 索引下推->将判断过程移到存储引擎层->减少回表
- MRR : 减少大量离散IO次数，因为一些查询不得不回表，大量随机IO，我们可以将辅助索引查询出的ID放在缓冲区的read_rnd_buffer中，等全部索引检索完成后，达到size，排序后得到一个有序ID集合在回表，就可以避免随机IO
- Index skip Scan 索引跳跃扫描：主要用户联合索引，没有遵循最左前缀原则，不用索引也让你用。其实也就是`MySQL`优化器会自动对联合索引中的第一个字段的值去重，然后基于去重后的值全部拼接起来查一遍，一句话来概述就是：**虽然你没用第一个字段，但我给你加上去，今天这个联合索引你就得用，不用也得给我用**。





